{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/text */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\n\nfunction $isRootTextContentEmpty(isEditorComposing) {\n  let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\n\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\n\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\n\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if (lexical.$isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\n\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Returns a touple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    } // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;","map":{"version":3,"names":["lexical","require","$findTextIntersectionFromCharacters","root","targetCharacters","node","getFirstChild","currentCharacters","mainLoop","$isElementNode","child","$isTextNode","characters","getTextContentSize","offset","sibling","getNextSibling","parent","getParent","parentSibling","$isRootTextContentEmpty","isEditorComposing","trim","arguments","length","undefined","text","$rootTextContent","$isRootTextContentEmptyCurry","$getRoot","getTextContent","$canShowPlaceholder","isComposing","children","getChildren","childrenLength","i","topBlock","$isDecoratorNode","$isParagraphNode","__indent","topBlockChildren","topBlockChildrenLength","s","$canShowPlaceholderCurry","registerLexicalTextEntity","editor","getMatch","targetNode","createNode","isTargetNode","replaceWithSimpleText","textNode","$createTextNode","setFormat","getFormat","replace","getMode","getLatest","__mode","textNodeTransform","isSimpleText","prevSibling","getPreviousSibling","currentNode","match","previousText","combinedText","prevMatch","diff","end","concatText","slice","newTextContent","select","setTextContent","remove","remainingText","start","nextText","nextSibling","nextMatch","markDirty","isTextEntity","nodeToReplace","splitText","replacementNode","reverseNodeTransform","removePlainTextTransform","registerNodeTransform","TextNode","removeReverseNodeTransform","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/@lexical/text/LexicalText.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/text */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n\n      currentCharacters += characters;\n    }\n\n    const sibling = node.getNextSibling();\n\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n\n    let parent = node.getParent();\n\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n\n      parent = parent.getParent();\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\n\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n\n  let text = $rootTextContent();\n\n  if (trim) {\n    text = text.trim();\n  }\n\n  return text === '';\n}\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\n\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\n\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\n\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n\n  if (childrenLength > 1) {\n    return false;\n  }\n\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n\n    if (lexical.$isDecoratorNode(topBlock)) {\n      return false;\n    }\n\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\n\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Returns a touple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    } // eslint-disable-next-line no-constant-condition\n\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n\n      if (match === null) {\n        return;\n      }\n\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n\n      let nodeToReplace;\n\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n\n    const nextSibling = node.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}