{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\nvar EditorState = require(\"./EditorState\");\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\nvar _require = require(\"./draftKeyUtils\"),\n  notEmptyKey = _require.notEmptyKey;\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\nvar keyCommandPlainBackspace = require(\"./keyCommandPlainBackspace\");\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\nvar isGecko = UserAgent.isEngine('Gecko');\nvar DOUBLE_NEWLINE = '\\n\\n';\nfunction onInputType(inputType, editorState) {\n  switch (inputType) {\n    case 'deleteContentBackward':\n      return keyCommandPlainBackspace(editorState);\n  }\n  return editorState;\n}\n/**\n * This function serves two purposes\n *\n * 1. To update the editorState and call onChange method with the new\n * editorState. This editorState is calculated in editOnBeforeInput but the\n * onChange method is not called with the new state until this method does it.\n * It is done to handle a specific case where certain character inputs might\n * be replaced with something else. E.g. snippets ('rc' might be replaced\n * with boilerplate code for react component). More information on the\n * exact problem can be found here -\n * https://github.com/facebook/draft-js/commit/07892ba479bd4dfc6afd1e0ed179aaf51cd138b1\n *\n * 2. intended to handle spellcheck and autocorrect changes,\n * which occur in the DOM natively without any opportunity to observe or\n * interpret the changes before they occur.\n *\n * The `input` event fires in contentEditable elements reliably for non-IE\n * browsers, immediately after changes occur to the editor DOM. Since our other\n * handlers override or otherwise handle cover other varieties of text input,\n * the DOM state should match the model in all controlled input cases. Thus,\n * when an `input` change leads to a DOM/model mismatch, the change should be\n * due to a spellcheck change, and we can incorporate it into our model.\n */\n\nfunction editOnInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  } // at this point editor is not null for sure (after input)\n\n  var castedEditorElement = editor.editor;\n  var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();\n  var anchorNode = domSelection.anchorNode,\n    isCollapsed = domSelection.isCollapsed;\n  var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;\n  if (anchorNode == null || isNotTextOrElementNode) {\n    // TODO: (t16149272) figure out context for this change\n    return;\n  }\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\n    // When typing at the beginning of a visual line, Chrome splits the text\n    // nodes into two. Why? No one knows. This commit is suspicious:\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\n    // To work around, we'll merge the sibling text nodes back into this one.\n    var span = anchorNode.parentNode;\n    if (span == null) {\n      // Handle null-parent case.\n      return;\n    }\n    anchorNode.nodeValue = span.textContent;\n    for (var child = span.firstChild; child != null; child = child.nextSibling) {\n      if (child !== anchorNode) {\n        span.removeChild(child);\n      }\n    }\n  }\n  var domText = anchorNode.textContent;\n  var editorState = editor._latestEditorState;\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\n    blockKey = _DraftOffsetKey$decod.blockKey,\n    decoratorKey = _DraftOffsetKey$decod.decoratorKey,\n    leafKey = _DraftOffsetKey$decod.leafKey;\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\n    start = _editorState$getBlock.start,\n    end = _editorState$getBlock.end;\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(blockKey);\n  var modelText = block.getText().slice(start, end); // Special-case soft newlines here. If the DOM text ends in a soft newline,\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\n  // We want to remove this extra newline for the purpose of our comparison\n  // of DOM and model text.\n\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\n    domText = domText.slice(0, -1);\n  } // No change -- the DOM is up to date. Nothing to do here.\n\n  if (domText === modelText) {\n    // This can be buggy for some Android keyboards because they don't fire\n    // standard onkeydown/pressed events and only fired editOnInput\n    // so domText is already changed by the browser and ends up being equal\n    // to modelText unexpectedly.\n    // Newest versions of Android support the dom-inputevent-inputtype\n    // and we can use the `inputType` to properly apply the state changes.\n\n    /* $FlowFixMe[prop-missing] inputType is only defined on a draft of a\n     * standard. https://w3c.github.io/input-events/#dom-inputevent-inputtype\n     */\n    var inputType = e.nativeEvent.inputType;\n    if (inputType) {\n      var newEditorState = onInputType(inputType, editorState);\n      if (newEditorState !== editorState) {\n        editor.restoreEditorDOM();\n        editor.update(newEditorState);\n        return;\n      }\n    }\n    return;\n  }\n  var selection = editorState.getSelection(); // We'll replace the entire leaf with the text content of the target.\n\n  var targetRange = selection.merge({\n    anchorOffset: start,\n    focusOffset: end,\n    isBackward: false\n  });\n  var entityKey = block.getEntityAt(start);\n  var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;\n  var entityType = entity != null ? entity.getMutability() : null;\n  var preserveEntity = entityType === 'MUTABLE'; // Immutable or segmented entities cannot properly be handled by the\n  // default browser undo, so we have to use a different change type to\n  // force using our internal undo method instead of falling through to the\n  // native browser undo.\n\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\n  var anchorOffset, focusOffset, startOffset, endOffset;\n  if (isGecko) {\n    // Firefox selection does not change while the context menu is open, so\n    // we preserve the anchor and focus values of the DOM selection.\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    startOffset = start + Math.min(anchorOffset, focusOffset);\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\n    anchorOffset = startOffset;\n    focusOffset = endOffset;\n  } else {\n    // Browsers other than Firefox may adjust DOM selection while the context\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\n    // and adjust it based on the number of characters changed during the\n    // mutation.\n    var charDelta = domText.length - modelText.length;\n    startOffset = selection.getStartOffset();\n    endOffset = selection.getEndOffset();\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\n    focusOffset = endOffset + charDelta;\n  } // Segmented entities are completely or partially removed when their\n  // text content changes. For this case we do not want any text to be selected\n  // after the change, so we are not merging the selection.\n\n  var contentWithAdjustedDOMSelection = newContent.merge({\n    selectionBefore: content.getSelectionAfter(),\n    selectionAfter: selection.merge({\n      anchorOffset: anchorOffset,\n      focusOffset: focusOffset\n    })\n  });\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\n}\nmodule.exports = editOnInput;","map":{"version":3,"names":["DraftModifier","require","DraftOffsetKey","EditorState","UserAgent","_require","notEmptyKey","findAncestorOffsetKey","keyCommandPlainBackspace","nullthrows","isGecko","isEngine","DOUBLE_NEWLINE","onInputType","inputType","editorState","editOnInput","editor","e","_pendingStateFromBeforeInput","undefined","update","castedEditorElement","domSelection","ownerDocument","defaultView","getSelection","anchorNode","isCollapsed","isNotTextOrElementNode","nodeType","Node","TEXT_NODE","ELEMENT_NODE","previousSibling","nextSibling","span","parentNode","nodeValue","textContent","child","firstChild","removeChild","domText","_latestEditorState","offsetKey","_DraftOffsetKey$decod","decode","blockKey","decoratorKey","leafKey","_editorState$getBlock","getBlockTree","getIn","start","end","content","getCurrentContent","block","getBlockForKey","modelText","getText","slice","endsWith","nativeEvent","newEditorState","restoreEditorDOM","selection","targetRange","merge","anchorOffset","focusOffset","isBackward","entityKey","getEntityAt","entity","getEntity","entityType","getMutability","preserveEntity","changeType","newContent","replaceText","getInlineStyleAt","startOffset","endOffset","Math","min","abs","charDelta","length","getStartOffset","getEndOffset","contentWithAdjustedDOMSelection","selectionBefore","getSelectionAfter","selectionAfter","push","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/editOnInput.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\n\nvar _require = require(\"./draftKeyUtils\"),\n    notEmptyKey = _require.notEmptyKey;\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\n\nvar keyCommandPlainBackspace = require(\"./keyCommandPlainBackspace\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\nvar isGecko = UserAgent.isEngine('Gecko');\nvar DOUBLE_NEWLINE = '\\n\\n';\n\nfunction onInputType(inputType, editorState) {\n  switch (inputType) {\n    case 'deleteContentBackward':\n      return keyCommandPlainBackspace(editorState);\n  }\n\n  return editorState;\n}\n/**\n * This function serves two purposes\n *\n * 1. To update the editorState and call onChange method with the new\n * editorState. This editorState is calculated in editOnBeforeInput but the\n * onChange method is not called with the new state until this method does it.\n * It is done to handle a specific case where certain character inputs might\n * be replaced with something else. E.g. snippets ('rc' might be replaced\n * with boilerplate code for react component). More information on the\n * exact problem can be found here -\n * https://github.com/facebook/draft-js/commit/07892ba479bd4dfc6afd1e0ed179aaf51cd138b1\n *\n * 2. intended to handle spellcheck and autocorrect changes,\n * which occur in the DOM natively without any opportunity to observe or\n * interpret the changes before they occur.\n *\n * The `input` event fires in contentEditable elements reliably for non-IE\n * browsers, immediately after changes occur to the editor DOM. Since our other\n * handlers override or otherwise handle cover other varieties of text input,\n * the DOM state should match the model in all controlled input cases. Thus,\n * when an `input` change leads to a DOM/model mismatch, the change should be\n * due to a spellcheck change, and we can incorporate it into our model.\n */\n\n\nfunction editOnInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  } // at this point editor is not null for sure (after input)\n\n\n  var castedEditorElement = editor.editor;\n  var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();\n  var anchorNode = domSelection.anchorNode,\n      isCollapsed = domSelection.isCollapsed;\n  var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;\n\n  if (anchorNode == null || isNotTextOrElementNode) {\n    // TODO: (t16149272) figure out context for this change\n    return;\n  }\n\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\n    // When typing at the beginning of a visual line, Chrome splits the text\n    // nodes into two. Why? No one knows. This commit is suspicious:\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\n    // To work around, we'll merge the sibling text nodes back into this one.\n    var span = anchorNode.parentNode;\n\n    if (span == null) {\n      // Handle null-parent case.\n      return;\n    }\n\n    anchorNode.nodeValue = span.textContent;\n\n    for (var child = span.firstChild; child != null; child = child.nextSibling) {\n      if (child !== anchorNode) {\n        span.removeChild(child);\n      }\n    }\n  }\n\n  var domText = anchorNode.textContent;\n  var editorState = editor._latestEditorState;\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\n\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\n      blockKey = _DraftOffsetKey$decod.blockKey,\n      decoratorKey = _DraftOffsetKey$decod.decoratorKey,\n      leafKey = _DraftOffsetKey$decod.leafKey;\n\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\n      start = _editorState$getBlock.start,\n      end = _editorState$getBlock.end;\n\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(blockKey);\n  var modelText = block.getText().slice(start, end); // Special-case soft newlines here. If the DOM text ends in a soft newline,\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\n  // We want to remove this extra newline for the purpose of our comparison\n  // of DOM and model text.\n\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\n    domText = domText.slice(0, -1);\n  } // No change -- the DOM is up to date. Nothing to do here.\n\n\n  if (domText === modelText) {\n    // This can be buggy for some Android keyboards because they don't fire\n    // standard onkeydown/pressed events and only fired editOnInput\n    // so domText is already changed by the browser and ends up being equal\n    // to modelText unexpectedly.\n    // Newest versions of Android support the dom-inputevent-inputtype\n    // and we can use the `inputType` to properly apply the state changes.\n\n    /* $FlowFixMe[prop-missing] inputType is only defined on a draft of a\n     * standard. https://w3c.github.io/input-events/#dom-inputevent-inputtype\n     */\n    var inputType = e.nativeEvent.inputType;\n\n    if (inputType) {\n      var newEditorState = onInputType(inputType, editorState);\n\n      if (newEditorState !== editorState) {\n        editor.restoreEditorDOM();\n        editor.update(newEditorState);\n        return;\n      }\n    }\n\n    return;\n  }\n\n  var selection = editorState.getSelection(); // We'll replace the entire leaf with the text content of the target.\n\n  var targetRange = selection.merge({\n    anchorOffset: start,\n    focusOffset: end,\n    isBackward: false\n  });\n  var entityKey = block.getEntityAt(start);\n  var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;\n  var entityType = entity != null ? entity.getMutability() : null;\n  var preserveEntity = entityType === 'MUTABLE'; // Immutable or segmented entities cannot properly be handled by the\n  // default browser undo, so we have to use a different change type to\n  // force using our internal undo method instead of falling through to the\n  // native browser undo.\n\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\n  var anchorOffset, focusOffset, startOffset, endOffset;\n\n  if (isGecko) {\n    // Firefox selection does not change while the context menu is open, so\n    // we preserve the anchor and focus values of the DOM selection.\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    startOffset = start + Math.min(anchorOffset, focusOffset);\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\n    anchorOffset = startOffset;\n    focusOffset = endOffset;\n  } else {\n    // Browsers other than Firefox may adjust DOM selection while the context\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\n    // and adjust it based on the number of characters changed during the\n    // mutation.\n    var charDelta = domText.length - modelText.length;\n    startOffset = selection.getStartOffset();\n    endOffset = selection.getEndOffset();\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\n    focusOffset = endOffset + charDelta;\n  } // Segmented entities are completely or partially removed when their\n  // text content changes. For this case we do not want any text to be selected\n  // after the change, so we are not merging the selection.\n\n\n  var contentWithAdjustedDOMSelection = newContent.merge({\n    selectionBefore: content.getSelectionAfter(),\n    selectionAfter: selection.merge({\n      anchorOffset: anchorOffset,\n      focusOffset: focusOffset\n    })\n  });\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\n}\n\nmodule.exports = editOnInput;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAE9C,IAAIC,cAAc,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAEhD,IAAIE,WAAW,GAAGF,OAAO,CAAC,eAAe,CAAC;AAE1C,IAAIG,SAAS,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AAE7C,IAAII,QAAQ,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;EACrCK,WAAW,GAAGD,QAAQ,CAACC,WAAW;AAEtC,IAAIC,qBAAqB,GAAGN,OAAO,CAAC,yBAAyB,CAAC;AAE9D,IAAIO,wBAAwB,GAAGP,OAAO,CAAC,4BAA4B,CAAC;AAEpE,IAAIQ,UAAU,GAAGR,OAAO,CAAC,qBAAqB,CAAC;AAE/C,IAAIS,OAAO,GAAGN,SAAS,CAACO,QAAQ,CAAC,OAAO,CAAC;AACzC,IAAIC,cAAc,GAAG,MAAM;AAE3B,SAASC,WAAWA,CAACC,SAAS,EAAEC,WAAW,EAAE;EAC3C,QAAQD,SAAS;IACf,KAAK,uBAAuB;MAC1B,OAAON,wBAAwB,CAACO,WAAW,CAAC;EAAC;EAGjD,OAAOA,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,WAAWA,CAACC,MAAM,EAAEC,CAAC,EAAE;EAC9B,IAAID,MAAM,CAACE,4BAA4B,KAAKC,SAAS,EAAE;IACrDH,MAAM,CAACI,MAAM,CAACJ,MAAM,CAACE,4BAA4B,CAAC;IAClDF,MAAM,CAACE,4BAA4B,GAAGC,SAAS;EACjD,CAAC,CAAC;;EAGF,IAAIE,mBAAmB,GAAGL,MAAM,CAACA,MAAM;EACvC,IAAIM,YAAY,GAAGD,mBAAmB,CAACE,aAAa,CAACC,WAAW,CAACC,YAAY,EAAE;EAC/E,IAAIC,UAAU,GAAGJ,YAAY,CAACI,UAAU;IACpCC,WAAW,GAAGL,YAAY,CAACK,WAAW;EAC1C,IAAIC,sBAAsB,GAAG,CAACF,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACG,QAAQ,MAAMC,IAAI,CAACC,SAAS,IAAI,CAACL,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACG,QAAQ,MAAMC,IAAI,CAACE,YAAY;EAEpO,IAAIN,UAAU,IAAI,IAAI,IAAIE,sBAAsB,EAAE;IAChD;IACA;EACF;EAEA,IAAIF,UAAU,CAACG,QAAQ,KAAKC,IAAI,CAACC,SAAS,KAAKL,UAAU,CAACO,eAAe,KAAK,IAAI,IAAIP,UAAU,CAACQ,WAAW,KAAK,IAAI,CAAC,EAAE;IACtH;IACA;IACA;IACA;IACA,IAAIC,IAAI,GAAGT,UAAU,CAACU,UAAU;IAEhC,IAAID,IAAI,IAAI,IAAI,EAAE;MAChB;MACA;IACF;IAEAT,UAAU,CAACW,SAAS,GAAGF,IAAI,CAACG,WAAW;IAEvC,KAAK,IAAIC,KAAK,GAAGJ,IAAI,CAACK,UAAU,EAAED,KAAK,IAAI,IAAI,EAAEA,KAAK,GAAGA,KAAK,CAACL,WAAW,EAAE;MAC1E,IAAIK,KAAK,KAAKb,UAAU,EAAE;QACxBS,IAAI,CAACM,WAAW,CAACF,KAAK,CAAC;MACzB;IACF;EACF;EAEA,IAAIG,OAAO,GAAGhB,UAAU,CAACY,WAAW;EACpC,IAAIxB,WAAW,GAAGE,MAAM,CAAC2B,kBAAkB;EAC3C,IAAIC,SAAS,GAAGpC,UAAU,CAACF,qBAAqB,CAACoB,UAAU,CAAC,CAAC;EAE7D,IAAImB,qBAAqB,GAAG5C,cAAc,CAAC6C,MAAM,CAACF,SAAS,CAAC;IACxDG,QAAQ,GAAGF,qBAAqB,CAACE,QAAQ;IACzCC,YAAY,GAAGH,qBAAqB,CAACG,YAAY;IACjDC,OAAO,GAAGJ,qBAAqB,CAACI,OAAO;EAE3C,IAAIC,qBAAqB,GAAGpC,WAAW,CAACqC,YAAY,CAACJ,QAAQ,CAAC,CAACK,KAAK,CAAC,CAACJ,YAAY,EAAE,QAAQ,EAAEC,OAAO,CAAC,CAAC;IACnGI,KAAK,GAAGH,qBAAqB,CAACG,KAAK;IACnCC,GAAG,GAAGJ,qBAAqB,CAACI,GAAG;EAEnC,IAAIC,OAAO,GAAGzC,WAAW,CAAC0C,iBAAiB,EAAE;EAC7C,IAAIC,KAAK,GAAGF,OAAO,CAACG,cAAc,CAACX,QAAQ,CAAC;EAC5C,IAAIY,SAAS,GAAGF,KAAK,CAACG,OAAO,EAAE,CAACC,KAAK,CAACR,KAAK,EAAEC,GAAG,CAAC,CAAC,CAAC;EACnD;EACA;EACA;;EAEA,IAAIZ,OAAO,CAACoB,QAAQ,CAACnD,cAAc,CAAC,EAAE;IACpC+B,OAAO,GAAGA,OAAO,CAACmB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAChC,CAAC,CAAC;;EAGF,IAAInB,OAAO,KAAKiB,SAAS,EAAE;IACzB;IACA;IACA;IACA;IACA;IACA;;IAEA;AACJ;AACA;IACI,IAAI9C,SAAS,GAAGI,CAAC,CAAC8C,WAAW,CAAClD,SAAS;IAEvC,IAAIA,SAAS,EAAE;MACb,IAAImD,cAAc,GAAGpD,WAAW,CAACC,SAAS,EAAEC,WAAW,CAAC;MAExD,IAAIkD,cAAc,KAAKlD,WAAW,EAAE;QAClCE,MAAM,CAACiD,gBAAgB,EAAE;QACzBjD,MAAM,CAACI,MAAM,CAAC4C,cAAc,CAAC;QAC7B;MACF;IACF;IAEA;EACF;EAEA,IAAIE,SAAS,GAAGpD,WAAW,CAACW,YAAY,EAAE,CAAC,CAAC;;EAE5C,IAAI0C,WAAW,GAAGD,SAAS,CAACE,KAAK,CAAC;IAChCC,YAAY,EAAEhB,KAAK;IACnBiB,WAAW,EAAEhB,GAAG;IAChBiB,UAAU,EAAE;EACd,CAAC,CAAC;EACF,IAAIC,SAAS,GAAGf,KAAK,CAACgB,WAAW,CAACpB,KAAK,CAAC;EACxC,IAAIqB,MAAM,GAAGrE,WAAW,CAACmE,SAAS,CAAC,GAAGjB,OAAO,CAACoB,SAAS,CAACH,SAAS,CAAC,GAAG,IAAI;EACzE,IAAII,UAAU,GAAGF,MAAM,IAAI,IAAI,GAAGA,MAAM,CAACG,aAAa,EAAE,GAAG,IAAI;EAC/D,IAAIC,cAAc,GAAGF,UAAU,KAAK,SAAS,CAAC,CAAC;EAC/C;EACA;EACA;;EAEA,IAAIG,UAAU,GAAGD,cAAc,GAAG,mBAAmB,GAAG,cAAc;EACtE,IAAIE,UAAU,GAAGjF,aAAa,CAACkF,WAAW,CAAC1B,OAAO,EAAEY,WAAW,EAAEzB,OAAO,EAAEe,KAAK,CAACyB,gBAAgB,CAAC7B,KAAK,CAAC,EAAEyB,cAAc,GAAGrB,KAAK,CAACgB,WAAW,CAACpB,KAAK,CAAC,GAAG,IAAI,CAAC;EAC1J,IAAIgB,YAAY,EAAEC,WAAW,EAAEa,WAAW,EAAEC,SAAS;EAErD,IAAI3E,OAAO,EAAE;IACX;IACA;IACA4D,YAAY,GAAG/C,YAAY,CAAC+C,YAAY;IACxCC,WAAW,GAAGhD,YAAY,CAACgD,WAAW;IACtCa,WAAW,GAAG9B,KAAK,GAAGgC,IAAI,CAACC,GAAG,CAACjB,YAAY,EAAEC,WAAW,CAAC;IACzDc,SAAS,GAAGD,WAAW,GAAGE,IAAI,CAACE,GAAG,CAAClB,YAAY,GAAGC,WAAW,CAAC;IAC9DD,YAAY,GAAGc,WAAW;IAC1Bb,WAAW,GAAGc,SAAS;EACzB,CAAC,MAAM;IACL;IACA;IACA;IACA;IACA;IACA,IAAII,SAAS,GAAG9C,OAAO,CAAC+C,MAAM,GAAG9B,SAAS,CAAC8B,MAAM;IACjDN,WAAW,GAAGjB,SAAS,CAACwB,cAAc,EAAE;IACxCN,SAAS,GAAGlB,SAAS,CAACyB,YAAY,EAAE;IACpCtB,YAAY,GAAG1C,WAAW,GAAGyD,SAAS,GAAGI,SAAS,GAAGL,WAAW;IAChEb,WAAW,GAAGc,SAAS,GAAGI,SAAS;EACrC,CAAC,CAAC;EACF;EACA;;EAGA,IAAII,+BAA+B,GAAGZ,UAAU,CAACZ,KAAK,CAAC;IACrDyB,eAAe,EAAEtC,OAAO,CAACuC,iBAAiB,EAAE;IAC5CC,cAAc,EAAE7B,SAAS,CAACE,KAAK,CAAC;MAC9BC,YAAY,EAAEA,YAAY;MAC1BC,WAAW,EAAEA;IACf,CAAC;EACH,CAAC,CAAC;EACFtD,MAAM,CAACI,MAAM,CAAClB,WAAW,CAAC8F,IAAI,CAAClF,WAAW,EAAE8E,+BAA+B,EAAEb,UAAU,CAAC,CAAC;AAC3F;AAEAkB,MAAM,CAACC,OAAO,GAAGnF,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}