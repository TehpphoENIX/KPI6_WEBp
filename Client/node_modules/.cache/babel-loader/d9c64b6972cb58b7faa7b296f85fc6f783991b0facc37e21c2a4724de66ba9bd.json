{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n} // TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode) {\n  let targetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = window.getSelection();\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;","map":{"version":3,"names":["html","require","selection","utils","lexical","$getHtmlContent","editor","$getSelection","Error","$isRangeSelection","isCollapsed","getNodes","length","$generateHtmlFromNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","dom","parseFromString","$generateNodesFromDOM","lines","split","linesLength","i","insertText","insertParagraph","isSelectionInsideOfGrid","DEPRECATED_$isGridSelection","$findMatchingParent","anchor","getNode","n","DEPRECATED_$isGridCellNode","focus","DEPRECATED_$isGridNode","$mergeGridNodesStrategy","$basicInsertStrategy","topLevelBlocks","currentBlock","node","isLineBreakNode","$isLineBreakNode","$isDecoratorNode","isInline","$isElementNode","$isTextNode","isParentRequired","createParentElementNode","push","append","insertNodes","anchorCell","isFromLexical","newGrid","newGridRows","getChildren","newColumnCount","getFirstChildOrThrow","getChildrenSize","newRowCount","gridCellNode","gridRowNode","DEPRECATED_$isGridRowNode","gridNode","startY","getIndexWithinParent","stopY","Math","min","startX","stopX","fromX","fromY","toX","max","toY","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","r","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","c","currentGridCellNode","newGridCellNode","getKey","originalChildren","forEach","child","paragraphNode","$createParagraphNode","remove","newGridSelection","DEPRECATED_$createGridSelection","set","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","undefined","exportNodeToJSON","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","selection$1","currentNode","targetArray","arguments","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","$cloneWithProperties","$sliceSelectedTextNodeContent","__text","childNode","shouldIncludeChild","extractWithChild","serializedChildNode","root","$getRoot","topLevelChildren","topLevelNode","serializedNodes","$parseSerializedNode","$addNodeStyle","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","domSelection","document","getSelection","element","createElement","style","cssText","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","COPY_COMMAND","secondEvent","ClipboardEvent","window","clearTimeout","COMMAND_PRIORITY_CRITICAL","setTimeout","execCommand","anchorDOM","anchorNode","focusDOM","focusNode","isSelectionWithinEditor","preventDefault","clipboardData","plainString","getTextContent","setData","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/@lexical/clipboard/LexicalClipboard.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n} // TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = window.getSelection();\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,eAAe,CAAC;AACnC,IAAIC,SAAS,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIE,KAAK,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIG,OAAO,GAAGH,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,eAAeA,CAACC,MAAM,EAAE;EAC/B,MAAMJ,SAAS,GAAGE,OAAO,CAACG,aAAa,EAAE;EAEzC,IAAIL,SAAS,IAAI,IAAI,EAAE;IACrB;MACE,MAAMM,KAAK,CAAE,iCAAgC,CAAC;IAChD;EACF,CAAC,CAAC;;EAGF,IAAIJ,OAAO,CAACK,iBAAiB,CAACP,SAAS,CAAC,IAAIA,SAAS,CAACQ,WAAW,EAAE,IAAIR,SAAS,CAACS,QAAQ,EAAE,CAACC,MAAM,KAAK,CAAC,EAAE;IACxG,OAAO,EAAE;EACX;EAEA,OAAOZ,IAAI,CAACa,sBAAsB,CAACP,MAAM,EAAEJ,SAAS,CAAC;AACvD,CAAC,CAAC;AACF;;AAEA,SAASY,kBAAkBA,CAACR,MAAM,EAAE;EAClC,MAAMJ,SAAS,GAAGE,OAAO,CAACG,aAAa,EAAE;EAEzC,IAAIL,SAAS,IAAI,IAAI,EAAE;IACrB;MACE,MAAMM,KAAK,CAAE,iCAAgC,CAAC;IAChD;EACF,CAAC,CAAC;;EAGF,IAAIJ,OAAO,CAACK,iBAAiB,CAACP,SAAS,CAAC,IAAIA,SAAS,CAACQ,WAAW,EAAE,IAAIR,SAAS,CAACS,QAAQ,EAAE,CAACC,MAAM,KAAK,CAAC,EAAE;IACxG,OAAO,IAAI;EACb;EAEA,OAAOG,IAAI,CAACC,SAAS,CAACC,8BAA8B,CAACX,MAAM,EAAEJ,SAAS,CAAC,CAAC;AAC1E;AACA,SAASgB,+BAA+BA,CAACC,YAAY,EAAEjB,SAAS,EAAE;EAChE,MAAMkB,IAAI,GAAGD,YAAY,CAACE,OAAO,CAAC,YAAY,CAAC;EAE/C,IAAID,IAAI,IAAI,IAAI,EAAE;IAChBlB,SAAS,CAACoB,aAAa,CAACF,IAAI,CAAC;EAC/B;AACF;AACA,SAASG,8BAA8BA,CAACJ,YAAY,EAAEjB,SAAS,EAAEI,MAAM,EAAE;EACvE,MAAMkB,aAAa,GAAGL,YAAY,CAACE,OAAO,CAAC,8BAA8B,CAAC;EAE1E,IAAIG,aAAa,EAAE;IACjB,IAAI;MACF,MAAMC,OAAO,GAAGV,IAAI,CAACW,KAAK,CAACF,aAAa,CAAC;MAEzC,IAAIC,OAAO,CAACE,SAAS,KAAKrB,MAAM,CAACsB,OAAO,CAACD,SAAS,IAAIE,KAAK,CAACC,OAAO,CAACL,OAAO,CAACM,KAAK,CAAC,EAAE;QAClF,MAAMA,KAAK,GAAGC,iCAAiC,CAACP,OAAO,CAACM,KAAK,CAAC;QAC9D,OAAOE,qBAAqB,CAAC3B,MAAM,EAAEyB,KAAK,EAAE7B,SAAS,CAAC;MACxD;IACF,CAAC,CAAC,MAAM,CAAC;IAAA;EAEX;EAEA,MAAMgC,UAAU,GAAGf,YAAY,CAACE,OAAO,CAAC,WAAW,CAAC;EAEpD,IAAIa,UAAU,EAAE;IACd,IAAI;MACF,MAAMC,MAAM,GAAG,IAAIC,SAAS,EAAE;MAC9B,MAAMC,GAAG,GAAGF,MAAM,CAACG,eAAe,CAACJ,UAAU,EAAE,WAAW,CAAC;MAC3D,MAAMH,KAAK,GAAG/B,IAAI,CAACuC,qBAAqB,CAACjC,MAAM,EAAE+B,GAAG,CAAC;MACrD,OAAOJ,qBAAqB,CAAC3B,MAAM,EAAEyB,KAAK,EAAE7B,SAAS,CAAC;IACxD,CAAC,CAAC,MAAM,CAAC;IAAA;EAEX,CAAC,CAAC;EACF;;EAGA,MAAMkB,IAAI,GAAGD,YAAY,CAACE,OAAO,CAAC,YAAY,CAAC;EAE/C,IAAID,IAAI,IAAI,IAAI,EAAE;IAChB,IAAIhB,OAAO,CAACK,iBAAiB,CAACP,SAAS,CAAC,EAAE;MACxC,MAAMsC,KAAK,GAAGpB,IAAI,CAACqB,KAAK,CAAC,OAAO,CAAC;MACjC,MAAMC,WAAW,GAAGF,KAAK,CAAC5B,MAAM;MAEhC,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;QACpCzC,SAAS,CAAC0C,UAAU,CAACJ,KAAK,CAACG,CAAC,CAAC,CAAC;QAE9B,IAAIA,CAAC,GAAGD,WAAW,GAAG,CAAC,EAAE;UACvBxC,SAAS,CAAC2C,eAAe,EAAE;QAC7B;MACF;IACF,CAAC,MAAM;MACL3C,SAAS,CAACoB,aAAa,CAACF,IAAI,CAAC;IAC/B;EACF;AACF;AACA,SAASa,qBAAqBA,CAAC3B,MAAM,EAAEyB,KAAK,EAAE7B,SAAS,EAAE;EACvD,MAAM4C,uBAAuB,GAAG1C,OAAO,CAAC2C,2BAA2B,CAAC7C,SAAS,CAAC,IAAIC,KAAK,CAAC6C,mBAAmB,CAAC9C,SAAS,CAAC+C,MAAM,CAACC,OAAO,EAAE,EAAEC,CAAC,IAAI/C,OAAO,CAACgD,0BAA0B,CAACD,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIhD,KAAK,CAAC6C,mBAAmB,CAAC9C,SAAS,CAACmD,KAAK,CAACH,OAAO,EAAE,EAAEC,CAAC,IAAI/C,OAAO,CAACgD,0BAA0B,CAACD,CAAC,CAAC,CAAC,KAAK,IAAI;EAEzS,IAAIL,uBAAuB,IAAIf,KAAK,CAACnB,MAAM,KAAK,CAAC,IAAIR,OAAO,CAACkD,sBAAsB,CAACvB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;IAC7FwB,uBAAuB,CAACxB,KAAK,EAAE7B,SAAS,EAAE,KAAK,EAAEI,MAAM,CAAC;IACxD;EACF;EAEAkD,oBAAoB,CAACzB,KAAK,EAAE7B,SAAS,CAAC;EACtC;AACF;AAEA,SAASsD,oBAAoBA,CAACzB,KAAK,EAAE7B,SAAS,EAAE;EAC9C;EACA,MAAMuD,cAAc,GAAG,EAAE;EACzB,IAAIC,YAAY,GAAG,IAAI;EAEvB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACnB,MAAM,EAAE+B,CAAC,EAAE,EAAE;IACrC,MAAMgB,IAAI,GAAG5B,KAAK,CAACY,CAAC,CAAC;IACrB,MAAMiB,eAAe,GAAGxD,OAAO,CAACyD,gBAAgB,CAACF,IAAI,CAAC;IAEtD,IAAIC,eAAe,IAAIxD,OAAO,CAAC0D,gBAAgB,CAACH,IAAI,CAAC,IAAIA,IAAI,CAACI,QAAQ,EAAE,IAAI3D,OAAO,CAAC4D,cAAc,CAACL,IAAI,CAAC,IAAIA,IAAI,CAACI,QAAQ,EAAE,IAAI3D,OAAO,CAAC6D,WAAW,CAACN,IAAI,CAAC,IAAIA,IAAI,CAACO,gBAAgB,EAAE,EAAE;MACnL,IAAIR,YAAY,KAAK,IAAI,EAAE;QACzBA,YAAY,GAAGC,IAAI,CAACQ,uBAAuB,EAAE;QAC7CV,cAAc,CAACW,IAAI,CAACV,YAAY,CAAC,CAAC,CAAC;QACnC;;QAEA,IAAIE,eAAe,EAAE;UACnB;QACF;MACF;MAEA,IAAIF,YAAY,KAAK,IAAI,EAAE;QACzBA,YAAY,CAACW,MAAM,CAACV,IAAI,CAAC;MAC3B;IACF,CAAC,MAAM;MACLF,cAAc,CAACW,IAAI,CAACT,IAAI,CAAC;MACzBD,YAAY,GAAG,IAAI;IACrB;EACF;EAEA,IAAItD,OAAO,CAACK,iBAAiB,CAACP,SAAS,CAAC,EAAE;IACxCA,SAAS,CAACoE,WAAW,CAACb,cAAc,CAAC;EACvC,CAAC,MAAM,IAAIrD,OAAO,CAAC2C,2BAA2B,CAAC7C,SAAS,CAAC,EAAE;IACzD;IACA,MAAMqE,UAAU,GAAGrE,SAAS,CAAC+C,MAAM,CAACC,OAAO,EAAE;IAE7C,IAAI,CAAC9C,OAAO,CAACgD,0BAA0B,CAACmB,UAAU,CAAC,EAAE;MACnD;QACE,MAAM/D,KAAK,CAAE,sCAAqC,CAAC;MACrD;IACF;IAEA+D,UAAU,CAACF,MAAM,CAAC,GAAGZ,cAAc,CAAC;EACtC;AACF;AAEA,SAASF,uBAAuBA,CAACxB,KAAK,EAAE7B,SAAS,EAAEsE,aAAa,EAAElE,MAAM,EAAE;EACxE,IAAIyB,KAAK,CAACnB,MAAM,KAAK,CAAC,IAAI,CAACR,OAAO,CAACkD,sBAAsB,CAACvB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;IACnE;MACE,MAAMvB,KAAK,CAAE,mDAAkD,CAAC;IAClE;EACF;EAEA,MAAMiE,OAAO,GAAG1C,KAAK,CAAC,CAAC,CAAC;EACxB,MAAM2C,WAAW,GAAGD,OAAO,CAACE,WAAW,EAAE;EACzC,MAAMC,cAAc,GAAGH,OAAO,CAACI,oBAAoB,EAAE,CAACC,eAAe,EAAE;EACvE,MAAMC,WAAW,GAAGN,OAAO,CAACK,eAAe,EAAE;EAC7C,MAAME,YAAY,GAAG7E,KAAK,CAAC6C,mBAAmB,CAAC9C,SAAS,CAAC+C,MAAM,CAACC,OAAO,EAAE,EAAEC,CAAC,IAAI/C,OAAO,CAACgD,0BAA0B,CAACD,CAAC,CAAC,CAAC;EACtH,MAAM8B,WAAW,GAAGD,YAAY,IAAI7E,KAAK,CAAC6C,mBAAmB,CAACgC,YAAY,EAAE7B,CAAC,IAAI/C,OAAO,CAAC8E,yBAAyB,CAAC/B,CAAC,CAAC,CAAC;EACtH,MAAMgC,QAAQ,GAAGF,WAAW,IAAI9E,KAAK,CAAC6C,mBAAmB,CAACiC,WAAW,EAAE9B,CAAC,IAAI/C,OAAO,CAACkD,sBAAsB,CAACH,CAAC,CAAC,CAAC;EAE9G,IAAI,CAAC/C,OAAO,CAACgD,0BAA0B,CAAC4B,YAAY,CAAC,IAAI,CAAC5E,OAAO,CAAC8E,yBAAyB,CAACD,WAAW,CAAC,IAAI,CAAC7E,OAAO,CAACkD,sBAAsB,CAAC6B,QAAQ,CAAC,EAAE;IACrJ;MACE,MAAM3E,KAAK,CAAE,qEAAoE,CAAC;IACpF;EACF;EAEA,MAAM4E,MAAM,GAAGH,WAAW,CAACI,oBAAoB,EAAE;EACjD,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACL,QAAQ,CAACL,eAAe,EAAE,GAAG,CAAC,EAAEM,MAAM,GAAGL,WAAW,GAAG,CAAC,CAAC;EAChF,MAAMU,MAAM,GAAGT,YAAY,CAACK,oBAAoB,EAAE;EAClD,MAAMK,KAAK,GAAGH,IAAI,CAACC,GAAG,CAACP,WAAW,CAACH,eAAe,EAAE,GAAG,CAAC,EAAEW,MAAM,GAAGb,cAAc,GAAG,CAAC,CAAC;EACtF,MAAMe,KAAK,GAAGJ,IAAI,CAACC,GAAG,CAACC,MAAM,EAAEC,KAAK,CAAC;EACrC,MAAME,KAAK,GAAGL,IAAI,CAACC,GAAG,CAACJ,MAAM,EAAEE,KAAK,CAAC;EACrC,MAAMO,GAAG,GAAGN,IAAI,CAACO,GAAG,CAACL,MAAM,EAAEC,KAAK,CAAC;EACnC,MAAMK,GAAG,GAAGR,IAAI,CAACO,GAAG,CAACV,MAAM,EAAEE,KAAK,CAAC;EACnC,MAAMU,YAAY,GAAGb,QAAQ,CAACR,WAAW,EAAE;EAC3C,IAAIsB,SAAS,GAAG,CAAC;EACjB,IAAIC,gBAAgB;EACpB,IAAIC,eAAe;EAEnB,KAAK,IAAIC,CAAC,GAAGR,KAAK,EAAEQ,CAAC,IAAIL,GAAG,EAAEK,CAAC,EAAE,EAAE;IACjC,MAAMC,kBAAkB,GAAGL,YAAY,CAACI,CAAC,CAAC;IAE1C,IAAI,CAAChG,OAAO,CAAC8E,yBAAyB,CAACmB,kBAAkB,CAAC,EAAE;MAC1D;QACE,MAAM7F,KAAK,CAAE,wCAAuC,CAAC;MACvD;IACF;IAEA,MAAM8F,cAAc,GAAG5B,WAAW,CAACuB,SAAS,CAAC;IAE7C,IAAI,CAAC7F,OAAO,CAAC8E,yBAAyB,CAACoB,cAAc,CAAC,EAAE;MACtD;QACE,MAAM9F,KAAK,CAAE,wCAAuC,CAAC;MACvD;IACF;IAEA,MAAM+F,aAAa,GAAGF,kBAAkB,CAAC1B,WAAW,EAAE;IACtD,MAAM6B,gBAAgB,GAAGF,cAAc,CAAC3B,WAAW,EAAE;IACrD,IAAI8B,YAAY,GAAG,CAAC;IAEpB,KAAK,IAAIC,CAAC,GAAGf,KAAK,EAAEe,CAAC,IAAIb,GAAG,EAAEa,CAAC,EAAE,EAAE;MACjC,MAAMC,mBAAmB,GAAGJ,aAAa,CAACG,CAAC,CAAC;MAE5C,IAAI,CAACtG,OAAO,CAACgD,0BAA0B,CAACuD,mBAAmB,CAAC,EAAE;QAC5D;UACE,MAAMnG,KAAK,CAAE,yCAAwC,CAAC;QACxD;MACF;MAEA,MAAMoG,eAAe,GAAGJ,gBAAgB,CAACC,YAAY,CAAC;MAEtD,IAAI,CAACrG,OAAO,CAACgD,0BAA0B,CAACwD,eAAe,CAAC,EAAE;QACxD;UACE,MAAMpG,KAAK,CAAE,yCAAwC,CAAC;QACxD;MACF;MAEA,IAAI4F,CAAC,KAAKR,KAAK,IAAIc,CAAC,KAAKf,KAAK,EAAE;QAC9BO,gBAAgB,GAAGS,mBAAmB,CAACE,MAAM,EAAE;MACjD,CAAC,MAAM,IAAIT,CAAC,KAAKL,GAAG,IAAIW,CAAC,KAAKb,GAAG,EAAE;QACjCM,eAAe,GAAGQ,mBAAmB,CAACE,MAAM,EAAE;MAChD;MAEA,MAAMC,gBAAgB,GAAGH,mBAAmB,CAAChC,WAAW,EAAE;MAC1DiC,eAAe,CAACjC,WAAW,EAAE,CAACoC,OAAO,CAACC,KAAK,IAAI;QAC7C,IAAI5G,OAAO,CAAC6D,WAAW,CAAC+C,KAAK,CAAC,EAAE;UAC9B,MAAMC,aAAa,GAAG7G,OAAO,CAAC8G,oBAAoB,EAAE;UACpDD,aAAa,CAAC5C,MAAM,CAAC2C,KAAK,CAAC;UAC3BL,mBAAmB,CAACtC,MAAM,CAAC2C,KAAK,CAAC;QACnC,CAAC,MAAM;UACLL,mBAAmB,CAACtC,MAAM,CAAC2C,KAAK,CAAC;QACnC;MACF,CAAC,CAAC;MACFF,gBAAgB,CAACC,OAAO,CAAC5D,CAAC,IAAIA,CAAC,CAACgE,MAAM,EAAE,CAAC;MACzCV,YAAY,EAAE;IAChB;IAEAR,SAAS,EAAE;EACb;EAEA,IAAIC,gBAAgB,IAAIC,eAAe,EAAE;IACvC,MAAMiB,gBAAgB,GAAGhH,OAAO,CAACiH,+BAA+B,EAAE;IAClED,gBAAgB,CAACE,GAAG,CAACnC,QAAQ,CAAC0B,MAAM,EAAE,EAAEX,gBAAgB,EAAEC,eAAe,CAAC;IAC1E/F,OAAO,CAACmH,aAAa,CAACH,gBAAgB,CAAC;IACvC9G,MAAM,CAACkH,eAAe,CAACpH,OAAO,CAACqH,wBAAwB,EAAEC,SAAS,CAAC;EACrE;AACF;AAEA,SAASC,gBAAgBA,CAAChE,IAAI,EAAE;EAC9B,MAAMiE,cAAc,GAAGjE,IAAI,CAACkE,UAAU,EAAE;EACxC,MAAMC,SAAS,GAAGnE,IAAI,CAACoE,WAAW,CAAC,CAAC;;EAEpC,IAAIH,cAAc,CAACI,IAAI,KAAKF,SAAS,CAACG,OAAO,EAAE,EAAE;IAC/C;MACE,MAAMzH,KAAK,CAAE,qBAAoBsH,SAAS,CAACI,IAAK,oCAAmC,CAAC;IACtF;EACF,CAAC,CAAC;;EAGF,MAAMC,kBAAkB,GAAGP,cAAc,CAACQ,QAAQ;EAElD,IAAIhI,OAAO,CAAC4D,cAAc,CAACL,IAAI,CAAC,EAAE;IAChC,IAAI,CAAC9B,KAAK,CAACC,OAAO,CAACqG,kBAAkB,CAAC,EAAE;MACtC;QACE,MAAM3H,KAAK,CAAE,qBAAoBsH,SAAS,CAACI,IAAK,kEAAiE,CAAC;MACpH;IACF;EACF;EAEA,OAAON,cAAc;AACvB;AAEA,SAASS,kBAAkBA,CAAC/H,MAAM,EAAEgI,WAAW,EAAEC,WAAW,EAAoB;EAAA,IAAlBC,WAAW,GAAAC,SAAA,CAAA7H,MAAA,QAAA6H,SAAA,QAAAf,SAAA,GAAAe,SAAA,MAAG,EAAE;EAC5E,IAAIC,aAAa,GAAGJ,WAAW,IAAI,IAAI,GAAGC,WAAW,CAACI,UAAU,CAACL,WAAW,CAAC,GAAG,IAAI;EACpF,MAAMM,aAAa,GAAGxI,OAAO,CAAC4D,cAAc,CAACuE,WAAW,CAAC,IAAIA,WAAW,CAACM,eAAe,CAAC,MAAM,CAAC;EAChG,IAAIC,MAAM,GAAGP,WAAW;EAExB,IAAID,WAAW,KAAK,IAAI,EAAE;IACxB,IAAIS,KAAK,GAAG7I,SAAS,CAAC8I,oBAAoB,CAACT,WAAW,CAAC;IACvDQ,KAAK,GAAG3I,OAAO,CAAC6D,WAAW,CAAC8E,KAAK,CAAC,IAAIT,WAAW,IAAI,IAAI,GAAGpI,SAAS,CAAC+I,6BAA6B,CAACX,WAAW,EAAES,KAAK,CAAC,GAAGA,KAAK;IAC/HD,MAAM,GAAGC,KAAK;EAChB;EAEA,MAAMX,QAAQ,GAAGhI,OAAO,CAAC4D,cAAc,CAAC8E,MAAM,CAAC,GAAGA,MAAM,CAACnE,WAAW,EAAE,GAAG,EAAE;EAC3E,MAAMiD,cAAc,GAAGD,gBAAgB,CAACmB,MAAM,CAAC,CAAC,CAAC;EACjD;EACA;EACA;EACA;EACA;;EAEA,IAAI1I,OAAO,CAAC6D,WAAW,CAAC6E,MAAM,CAAC,EAAE;IAC/B,MAAM1H,IAAI,GAAG0H,MAAM,CAACI,MAAM,CAAC,CAAC;IAC5B;IACA;;IAEA,IAAI9H,IAAI,CAACR,MAAM,GAAG,CAAC,EAAE;MACnBgH,cAAc,CAACxG,IAAI,GAAGA,IAAI;IAC5B,CAAC,MAAM;MACLsH,aAAa,GAAG,KAAK;IACvB;EACF;EAEA,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyF,QAAQ,CAACxH,MAAM,EAAE+B,CAAC,EAAE,EAAE;IACxC,MAAMwG,SAAS,GAAGf,QAAQ,CAACzF,CAAC,CAAC;IAC7B,MAAMyG,kBAAkB,GAAGf,kBAAkB,CAAC/H,MAAM,EAAEgI,WAAW,EAAEa,SAAS,EAAEvB,cAAc,CAACQ,QAAQ,CAAC;IAEtG,IAAI,CAACM,aAAa,IAAItI,OAAO,CAAC4D,cAAc,CAACuE,WAAW,CAAC,IAAIa,kBAAkB,IAAIb,WAAW,CAACc,gBAAgB,CAACF,SAAS,EAAEb,WAAW,EAAE,OAAO,CAAC,EAAE;MAChJI,aAAa,GAAG,IAAI;IACtB;EACF;EAEA,IAAIA,aAAa,IAAI,CAACE,aAAa,EAAE;IACnCJ,WAAW,CAACpE,IAAI,CAACwD,cAAc,CAAC;EAClC,CAAC,MAAM,IAAI/F,KAAK,CAACC,OAAO,CAAC8F,cAAc,CAACQ,QAAQ,CAAC,EAAE;IACjD,KAAK,IAAIzF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiF,cAAc,CAACQ,QAAQ,CAACxH,MAAM,EAAE+B,CAAC,EAAE,EAAE;MACvD,MAAM2G,mBAAmB,GAAG1B,cAAc,CAACQ,QAAQ,CAACzF,CAAC,CAAC;MACtD6F,WAAW,CAACpE,IAAI,CAACkF,mBAAmB,CAAC;IACvC;EACF;EAEA,OAAOZ,aAAa;AACtB,CAAC,CAAC;;AAGF,SAASzH,8BAA8BA,CAACX,MAAM,EAAEJ,SAAS,EAAE;EACzD,MAAM6B,KAAK,GAAG,EAAE;EAChB,MAAMwH,IAAI,GAAGnJ,OAAO,CAACoJ,QAAQ,EAAE;EAC/B,MAAMC,gBAAgB,GAAGF,IAAI,CAAC5E,WAAW,EAAE;EAE3C,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,gBAAgB,CAAC7I,MAAM,EAAE+B,CAAC,EAAE,EAAE;IAChD,MAAM+G,YAAY,GAAGD,gBAAgB,CAAC9G,CAAC,CAAC;IACxC0F,kBAAkB,CAAC/H,MAAM,EAAEJ,SAAS,EAAEwJ,YAAY,EAAE3H,KAAK,CAAC;EAC5D;EAEA,OAAO;IACLJ,SAAS,EAAErB,MAAM,CAACsB,OAAO,CAACD,SAAS;IACnCI;EACF,CAAC;AACH;AACA,SAASC,iCAAiCA,CAAC2H,eAAe,EAAE;EAC1D,MAAM5H,KAAK,GAAG,EAAE;EAEhB,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgH,eAAe,CAAC/I,MAAM,EAAE+B,CAAC,EAAE,EAAE;IAC/C,MAAMiF,cAAc,GAAG+B,eAAe,CAAChH,CAAC,CAAC;IACzC,MAAMgB,IAAI,GAAGvD,OAAO,CAACwJ,oBAAoB,CAAChC,cAAc,CAAC;IAEzD,IAAIxH,OAAO,CAAC6D,WAAW,CAACN,IAAI,CAAC,EAAE;MAC7BzD,SAAS,CAAC2J,aAAa,CAAClG,IAAI,CAAC;IAC/B;IAEA5B,KAAK,CAACqC,IAAI,CAACT,IAAI,CAAC;EAClB;EAEA,OAAO5B,KAAK;AACd;AACA,MAAM+H,aAAa,GAAG,EAAE;AACxB,IAAIC,qBAAqB,GAAG,IAAI,CAAC,CAAC;AAClC;;AAEA,eAAeC,eAAeA,CAAC1J,MAAM,EAAE2J,KAAK,EAAE;EAC5C,IAAIF,qBAAqB,KAAK,IAAI,EAAE;IAClC;IACA;IACA,OAAO,KAAK;EACd;EAEA,IAAIE,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC9J,MAAM,CAAC+J,MAAM,CAAC,MAAM;QAClBF,OAAO,CAACG,qBAAqB,CAAChK,MAAM,EAAE2J,KAAK,CAAC,CAAC;MAC/C,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA,MAAMM,WAAW,GAAGjK,MAAM,CAACkK,cAAc,EAAE;EAC3C,MAAMC,YAAY,GAAGC,QAAQ,CAACC,YAAY,EAAE;EAE5C,IAAIJ,WAAW,KAAK,IAAI,IAAIE,YAAY,KAAK,IAAI,EAAE;IACjD,OAAO,KAAK;EACd;EAEA,MAAMG,OAAO,GAAGF,QAAQ,CAACG,aAAa,CAAC,MAAM,CAAC;EAC9CD,OAAO,CAACE,KAAK,CAACC,OAAO,GAAG,gCAAgC;EACxDH,OAAO,CAACvG,MAAM,CAACqG,QAAQ,CAACM,cAAc,CAAC,GAAG,CAAC,CAAC;EAC5CT,WAAW,CAAClG,MAAM,CAACuG,OAAO,CAAC;EAC3B,MAAMK,KAAK,GAAG,IAAIC,KAAK,EAAE;EACzBD,KAAK,CAACE,QAAQ,CAACP,OAAO,EAAE,CAAC,CAAC;EAC1BK,KAAK,CAACG,MAAM,CAACR,OAAO,EAAE,CAAC,CAAC;EACxBH,YAAY,CAACY,eAAe,EAAE;EAC9BZ,YAAY,CAACa,QAAQ,CAACL,KAAK,CAAC;EAC5B,OAAO,IAAIf,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMmB,cAAc,GAAGjL,MAAM,CAACkL,eAAe,CAACpL,OAAO,CAACqL,YAAY,EAAEC,WAAW,IAAI;MACjF,IAAIA,WAAW,YAAYC,cAAc,EAAE;QACzCJ,cAAc,EAAE;QAEhB,IAAIxB,qBAAqB,KAAK,IAAI,EAAE;UAClC6B,MAAM,CAACC,YAAY,CAAC9B,qBAAqB,CAAC;UAC1CA,qBAAqB,GAAG,IAAI;QAC9B;QAEAI,OAAO,CAACG,qBAAqB,CAAChK,MAAM,EAAEoL,WAAW,CAAC,CAAC;MACrD,CAAC,CAAC;;MAGF,OAAO,IAAI;IACb,CAAC,EAAEtL,OAAO,CAAC0L,yBAAyB,CAAC,CAAC,CAAC;IACvC;;IAEA/B,qBAAqB,GAAG6B,MAAM,CAACG,UAAU,CAAC,MAAM;MAC9CR,cAAc,EAAE;MAChBxB,qBAAqB,GAAG,IAAI;MAC5BI,OAAO,CAAC,KAAK,CAAC;IAChB,CAAC,EAAEL,aAAa,CAAC;IACjBY,QAAQ,CAACsB,WAAW,CAAC,MAAM,CAAC;IAC5BpB,OAAO,CAACzD,MAAM,EAAE;EAClB,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEF,SAASmD,qBAAqBA,CAAChK,MAAM,EAAE2J,KAAK,EAAE;EAC5C,MAAMQ,YAAY,GAAGmB,MAAM,CAACjB,YAAY,EAAE;EAE1C,IAAI,CAACF,YAAY,EAAE;IACjB,OAAO,KAAK;EACd;EAEA,MAAMwB,SAAS,GAAGxB,YAAY,CAACyB,UAAU;EACzC,MAAMC,QAAQ,GAAG1B,YAAY,CAAC2B,SAAS;EAEvC,IAAIH,SAAS,KAAK,IAAI,IAAIE,QAAQ,KAAK,IAAI,IAAI,CAAC/L,OAAO,CAACiM,uBAAuB,CAAC/L,MAAM,EAAE2L,SAAS,EAAEE,QAAQ,CAAC,EAAE;IAC5G,OAAO,KAAK;EACd;EAEAlC,KAAK,CAACqC,cAAc,EAAE;EACtB,MAAMC,aAAa,GAAGtC,KAAK,CAACsC,aAAa;EACzC,MAAMrM,SAAS,GAAGE,OAAO,CAACG,aAAa,EAAE;EAEzC,IAAIgM,aAAa,KAAK,IAAI,IAAIrM,SAAS,KAAK,IAAI,EAAE;IAChD,OAAO,KAAK;EACd;EAEA,MAAMgC,UAAU,GAAG7B,eAAe,CAACC,MAAM,CAAC;EAC1C,MAAMkB,aAAa,GAAGV,kBAAkB,CAACR,MAAM,CAAC;EAChD,IAAIkM,WAAW,GAAG,EAAE;EAEpB,IAAItM,SAAS,KAAK,IAAI,EAAE;IACtBsM,WAAW,GAAGtM,SAAS,CAACuM,cAAc,EAAE;EAC1C;EAEA,IAAIvK,UAAU,KAAK,IAAI,EAAE;IACvBqK,aAAa,CAACG,OAAO,CAAC,WAAW,EAAExK,UAAU,CAAC;EAChD;EAEA,IAAIV,aAAa,KAAK,IAAI,EAAE;IAC1B+K,aAAa,CAACG,OAAO,CAAC,8BAA8B,EAAElL,aAAa,CAAC;EACtE;EAEA+K,aAAa,CAACG,OAAO,CAAC,YAAY,EAAEF,WAAW,CAAC;EAChD,OAAO,IAAI;AACb;AAEAG,OAAO,CAAC1L,8BAA8B,GAAGA,8BAA8B;AACvE0L,OAAO,CAAC3K,iCAAiC,GAAGA,iCAAiC;AAC7E2K,OAAO,CAACtM,eAAe,GAAGA,eAAe;AACzCsM,OAAO,CAAC7L,kBAAkB,GAAGA,kBAAkB;AAC/C6L,OAAO,CAACzL,+BAA+B,GAAGA,+BAA+B;AACzEyL,OAAO,CAACpL,8BAA8B,GAAGA,8BAA8B;AACvEoL,OAAO,CAAC1K,qBAAqB,GAAGA,qBAAqB;AACrD0K,OAAO,CAAC3C,eAAe,GAAGA,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}