{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\nvar CharacterMetadata = require(\"./CharacterMetadata\");\nvar DataTransfer = require(\"fbjs/lib/DataTransfer\");\nvar DraftModifier = require(\"./DraftModifier\");\nvar DraftPasteProcessor = require(\"./DraftPasteProcessor\");\nvar EditorState = require(\"./EditorState\");\nvar RichTextEditorUtil = require(\"./RichTextEditorUtil\");\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\nvar getTextContentFromFiles = require(\"./getTextContentFromFiles\");\nvar isEventHandled = require(\"./isEventHandled\");\nvar splitTextIntoTextBlocks = require(\"./splitTextIntoTextBlocks\");\n/**\n * Paste content.\n */\n\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.\n\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n      /* $FlowFixMe[incompatible-call] This comment suppresses an error found\n       * DataTransfer was typed. getFiles() returns an array of <Files extends\n       * Blob>, not Blob */\n\n      getTextContentFromFiles(files, function ( /*string*/\n      fileText) {\n        fileText = fileText || defaultFileText;\n        if (!fileText) {\n          return;\n        }\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n      return;\n    }\n  }\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n  if (editor.props.formatPastedText) {\n    var _editor$props$formatP = editor.props.formatPastedText(text, html),\n      formattedText = _editor$props$formatP.text,\n      formattedHtml = _editor$props$formatP.html;\n    text = formattedText;\n    html = formattedHtml;\n  }\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n    if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {\n      var _html;\n      if (\n      // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 ||\n      // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    } // If there is html paste data, try to parse that.\n\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n          entityMap = htmlFragment.entityMap;\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    } // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n\n    editor.setClipboard(null);\n  }\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\nmodule.exports = editOnPaste;","map":{"version":3,"names":["BlockMapBuilder","require","CharacterMetadata","DataTransfer","DraftModifier","DraftPasteProcessor","EditorState","RichTextEditorUtil","getEntityKeyForSelection","getTextContentFromFiles","isEventHandled","splitTextIntoTextBlocks","editOnPaste","editor","e","preventDefault","data","clipboardData","isRichText","files","getFiles","defaultFileText","getText","length","props","handlePastedFiles","fileText","editorState","_latestEditorState","blocks","character","create","style","getCurrentInlineStyle","entity","getCurrentContent","getSelection","currentBlockType","getCurrentBlockType","text","processText","fragment","createFromArray","withInsertedText","replaceWithFragment","update","push","textBlocks","html","getHTML","formatPastedText","_editor$props$formatP","formattedText","formattedHtml","handlePastedText","stripPastedStyles","internalClipboard","getClipboard","_html","indexOf","getEditorKey","size","first","insertFragment","types","includes","areTextBlocksAndClipboardEqual","htmlFragment","processHTML","blockRenderMap","contentBlocks","entityMap","htmlMap","setClipboard","textFragment","textMap","newContent","set","blockMap","valueSeq","every","block","ii","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/editOnPaste.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar CharacterMetadata = require(\"./CharacterMetadata\");\n\nvar DataTransfer = require(\"fbjs/lib/DataTransfer\");\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar DraftPasteProcessor = require(\"./DraftPasteProcessor\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar RichTextEditorUtil = require(\"./RichTextEditorUtil\");\n\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\n\nvar getTextContentFromFiles = require(\"./getTextContentFromFiles\");\n\nvar isEventHandled = require(\"./isEventHandled\");\n\nvar splitTextIntoTextBlocks = require(\"./splitTextIntoTextBlocks\");\n/**\n * Paste content.\n */\n\n\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.\n\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n      /* $FlowFixMe[incompatible-call] This comment suppresses an error found\n       * DataTransfer was typed. getFiles() returns an array of <Files extends\n       * Blob>, not Blob */\n\n\n      getTextContentFromFiles(files, function (\n      /*string*/\n      fileText) {\n        fileText = fileText || defaultFileText;\n\n        if (!fileText) {\n          return;\n        }\n\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n      return;\n    }\n  }\n\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n\n  if (editor.props.formatPastedText) {\n    var _editor$props$formatP = editor.props.formatPastedText(text, html),\n        formattedText = _editor$props$formatP.text,\n        formattedHtml = _editor$props$formatP.html;\n\n    text = formattedText;\n    html = formattedHtml;\n  }\n\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n\n    if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {\n      var _html;\n\n      if ( // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 || // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    } // If there is html paste data, try to parse that.\n\n\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n            entityMap = htmlFragment.entityMap;\n\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    } // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n\n\n    editor.setClipboard(null);\n  }\n\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\n\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\n\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\n\nmodule.exports = editOnPaste;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}