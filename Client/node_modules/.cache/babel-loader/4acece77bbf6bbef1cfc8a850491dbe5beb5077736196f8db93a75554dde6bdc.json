{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\nvar Immutable = require(\"immutable\");\nvar List = Immutable.List,\n  Map = Immutable.Map;\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n  var block = blockMap.get(key);\n  if (!block) {\n    return;\n  }\n  blockMap.set(key, func(block));\n};\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\n\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n  if (!blockKey) {\n    return parents;\n  }\n  var blockNode = blockMap.get(blockKey);\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n  return parents;\n};\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\n\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n  if (!block) {\n    return nextDelimiters;\n  }\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n    nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance\n\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n  return nextDelimiters;\n};\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n  return nextValidSiblingKey;\n};\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n  return prevValidSiblingKey;\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update endblock if its retained\n\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update start block parent ancestors\n\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update start block next - can only happen if startBlock == endBlock\n\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    }); // update start block prev\n\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block next\n\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block prev\n\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    }); // update end block parent ancestors\n\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update next delimiters all the way to a root delimiter\n\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // if parent (startBlock) was deleted\n\n    if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {\n      var prevSiblingKey = startBlock.getPrevSiblingKey(); // endBlock becomes next sibling of parent's prevSibling\n\n      transformBlock(endBlock.getKey(), blocks, function (block) {\n        return block.merge({\n          prevSibling: prevSiblingKey\n        });\n      });\n      transformBlock(prevSiblingKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: endBlock.getKey()\n        });\n      }); // Update parent for previous parent's children, and children for that parent\n\n      var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;\n      var newParentKey = prevSibling ? prevSibling.getParentKey() : null;\n      startBlock.getChildKeys().forEach(function (childKey) {\n        transformBlock(childKey, blocks, function (block) {\n          return block.merge({\n            parent: newParentKey // set to null if there is no parent\n          });\n        });\n      });\n\n      if (newParentKey != null) {\n        var newParent = blockMap.get(newParentKey);\n        transformBlock(newParentKey, blocks, function (block) {\n          return block.merge({\n            children: newParent.getChildKeys().concat(startBlock.getChildKeys())\n          });\n        });\n      } // last child of deleted parent should point to next sibling\n\n      transformBlock(startBlock.getChildKeys().find(function (key) {\n        var block = blockMap.get(key);\n        return block.getNextSiblingKey() === null;\n      }), blocks, function (block) {\n        return block.merge({\n          nextSibling: startBlock.getNextSiblingKey()\n        });\n      });\n    }\n  });\n};\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together\n\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children\n\n  var parentAncestors = [];\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected siblings so we can not remove its ancestors parents\n\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    } // endBlock has children so can not remove this block or any of its ancestors\n\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    } // we need to retain all ancestors of the next delimiter block\n\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n  var characterList;\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  }); // If cursor (collapsed) is at the start of the first child, delete parent\n  // instead of child\n\n  var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;\n  var newBlocks = shouldDeleteParent ? Map([[startKey, null]]) : blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  }); // Only update tree block pointers if the range is across blocks\n\n  if (isExperimentalTreeBlock && startBlock !== endBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\n\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n  return targetList;\n};\nmodule.exports = removeRangeFromContentState;","map":{"version":3,"names":["ContentBlockNode","require","getNextDelimiterBlockKey","Immutable","List","Map","transformBlock","key","blockMap","func","block","get","set","getAncestorsKeys","blockKey","parents","blockNode","getParentKey","parentKey","push","getNextDelimitersBlockKeys","nextDelimiters","nextDelimiter","_block","getNextValidSibling","originalBlockMap","nextValidSiblingKey","getKey","getNextSiblingKey","getPrevValidSibling","prevValidSiblingKey","getPrevSiblingKey","updateBlockMapLinks","startBlock","endBlock","withMutations","blocks","merge","nextSibling","prevSibling","forEach","children","getChildKeys","filter","delimiterKey","prevSiblingKey","newParentKey","childKey","parent","newParent","concat","find","removeRangeFromContentState","contentState","selectionState","isCollapsed","getBlockMap","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","isExperimentalTreeBlock","parentAncestors","endBlockchildrenKeys","endBlockAncestors","isEmpty","characterList","removeFromList","getCharacterList","slice","modifiedStart","text","getText","shouldDeleteParent","newBlocks","toSeq","skipUntil","_","k","takeUntil","indexOf","map","updatedBlockMap","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","targetList","shift","count","pop","head","tail","toList","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/removeRangeFromContentState.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\n\n\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\n\n\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n\n    nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance\n\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update endblock if its retained\n\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update start block parent ancestors\n\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update start block next - can only happen if startBlock == endBlock\n\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    }); // update start block prev\n\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block next\n\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block prev\n\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    }); // update end block parent ancestors\n\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update next delimiters all the way to a root delimiter\n\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // if parent (startBlock) was deleted\n\n    if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {\n      var prevSiblingKey = startBlock.getPrevSiblingKey(); // endBlock becomes next sibling of parent's prevSibling\n\n      transformBlock(endBlock.getKey(), blocks, function (block) {\n        return block.merge({\n          prevSibling: prevSiblingKey\n        });\n      });\n      transformBlock(prevSiblingKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: endBlock.getKey()\n        });\n      }); // Update parent for previous parent's children, and children for that parent\n\n      var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;\n      var newParentKey = prevSibling ? prevSibling.getParentKey() : null;\n      startBlock.getChildKeys().forEach(function (childKey) {\n        transformBlock(childKey, blocks, function (block) {\n          return block.merge({\n            parent: newParentKey // set to null if there is no parent\n\n          });\n        });\n      });\n\n      if (newParentKey != null) {\n        var newParent = blockMap.get(newParentKey);\n        transformBlock(newParentKey, blocks, function (block) {\n          return block.merge({\n            children: newParent.getChildKeys().concat(startBlock.getChildKeys())\n          });\n        });\n      } // last child of deleted parent should point to next sibling\n\n\n      transformBlock(startBlock.getChildKeys().find(function (key) {\n        var block = blockMap.get(key);\n        return block.getNextSiblingKey() === null;\n      }), blocks, function (block) {\n        return block.merge({\n          nextSibling: startBlock.getNextSiblingKey()\n        });\n      });\n    }\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together\n\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children\n\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected siblings so we can not remove its ancestors parents\n\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    } // endBlock has children so can not remove this block or any of its ancestors\n\n\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    } // we need to retain all ancestors of the next delimiter block\n\n\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  }); // If cursor (collapsed) is at the start of the first child, delete parent\n  // instead of child\n\n  var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;\n  var newBlocks = shouldDeleteParent ? Map([[startKey, null]]) : blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  }); // Only update tree block pointers if the range is across blocks\n\n  if (isExperimentalTreeBlock && startBlock !== endBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\n\n\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}