{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\nvar ContentBlockNode = require(\"./ContentBlockNode\");\nvar Immutable = require(\"immutable\");\nvar insertIntoList = require(\"./insertIntoList\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\nvar List = Immutable.List;\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n  var type = targetBlock.getType();\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n    if (!lastSiblingKey) {\n      break;\n    }\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n  return rootBlocks;\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","mergeBlockData","arguments","length","undefined","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","data","getData","merge","type","getType","newBlock","slice","characterList","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar Immutable = require(\"immutable\");\n\nvar insertIntoList = require(\"./insertIntoList\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n\n  var type = targetBlock.getType();\n\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}