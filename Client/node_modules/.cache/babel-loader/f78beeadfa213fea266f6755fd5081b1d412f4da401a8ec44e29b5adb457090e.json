{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? dom.body.childNodes : [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement) {\n  let selection$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor) {\n  let forChildMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  let parentLexicalNode = arguments.length > 3 ? arguments[3] : undefined;\n  let preformatted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;","map":{"version":3,"names":["selection","require","lexical","$generateNodesFromDOM","editor","dom","lexicalNodes","elements","body","childNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$generateHtmlFromNodes","document","window","Error","container","createElement","root","$getRoot","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","selection$1","arguments","undefined","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","children","after","exportDOM","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","Set","node","forChildMap","Map","parentLexicalNode","preformatted","currentLexicalNode","transformFunction","transformOutput","postTransform","forChildFunction","push","forChild","set","childLexicalNodes","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/@lexical/html/LexicalHtml.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? dom.body.childNodes : [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}