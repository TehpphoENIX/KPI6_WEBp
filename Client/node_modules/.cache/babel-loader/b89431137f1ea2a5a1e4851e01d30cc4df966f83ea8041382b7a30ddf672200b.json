{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\nexports.registerDragonSupport = registerDragonSupport;","map":{"version":3,"names":["lexical","require","registerDragonSupport","editor","origin","window","location","handler","event","rootElement","getRootElement","document","activeElement","data","parsedData","JSON","parse","e","protocol","type","payload","functionId","args","elementStart","elementLength","text","selStart","selLength","formatCommand","update","selection","$getSelection","$isRangeSelection","anchor","anchorNode","getNode","setSelStart","setSelEnd","$isTextNode","setTextNodeRange","insertRawText","anchorNodeTextLength","getTextContentSize","stopImmediatePropagation","addEventListener","removeEventListener","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/@lexical/dragon/LexicalDragon.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n\n    const rootElement = editor.getRootElement();\n\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (typeof data === 'string') {\n      let parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}