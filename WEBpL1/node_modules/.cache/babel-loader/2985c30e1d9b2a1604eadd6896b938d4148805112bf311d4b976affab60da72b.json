{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classNames[_key - 1] = arguments[_key];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\n\nfunction removeClassNamesFromElement(element) {\n  for (var _len2 = arguments.length, classNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classNames[_key2 - 1] = arguments[_key2];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\n\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\n\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n/**\n *Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\n\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the compenent it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister() {\n  for (var _len3 = arguments.length, func = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    func[_key3] = arguments[_key3];\n  }\n  return () => {\n    func.forEach(f => f());\n  };\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\n\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\n\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\n\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexcial element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexcial element with the previous node appended within (as a child, including its children).\n */\n\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;","map":{"version":3,"names":["selection","require","lexical","addClassNamesToElement","element","_len","arguments","length","classNames","Array","_key","forEach","className","classesToAdd","split","filter","n","classList","add","removeClassNamesFromElement","_len2","_key2","remove","isMimeType","file","acceptableMimeTypes","acceptableType","type","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","value","next","fileReader","FileReader","addEventListener","result","push","readAsDataURL","$dfs","startingNode","endingNode","nodes","start","$getRoot","getLatest","end","$isElementNode","getLastDescendant","node","depth","$getDepth","is","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","Error","__key","findFn","curr","mergeRegister","_len3","func","_key3","f","registerNestedElementResolver","editor","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","i","child","parentNode","childNode","elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","append","canBeEmpty","registerNodeTransform","$restoreEditorState","editorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","clone","$cloneWithProperties","$isTextNode","__text","set","_dirtyType","selection$1","_selection","$setSelection","$insertNodeToNearestRoot","$getSelection","$isRangeSelection","focus","focusNode","getNode","focusOffset","offset","$isRootOrShadowRoot","focusChild","getChildAtIndex","insertBefore","selectNext","splitNode","splitOffset","getParentOrThrow","getIndexWithinParent","splitText","rightTree","$splitNode","selectStart","$isNodeSelection","DEPRECATED_$isGridSelection","getNodes","getTopLevelElementOrThrow","root","paragraphNode","$createParagraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","isHTMLAnchorElement","x","isHTMLElement","tagName","nodeType","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/@lexical/utils/LexicalUtils.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\n\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\n\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\n\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\n\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\n/**\n *Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\n\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the compenent it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\n\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\n\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\n\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexcial element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexcial element with the previous node appended within (as a child, including its children).\n */\n\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}