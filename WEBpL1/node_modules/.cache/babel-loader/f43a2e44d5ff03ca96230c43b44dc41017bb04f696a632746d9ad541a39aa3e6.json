{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\nvar warning = require(\"fbjs/lib/warning\");\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n    var nextSiblingKey = block.getNextSiblingKey();\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n    return true;\n  },\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n      nodesSeen++;\n    }\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n    return true;\n  },\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n    var blocks = blockMap.toArray();\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;","map":{"version":3,"names":["warning","require","DraftTreeInvariants","isValidBlock","block","blockMap","key","getKey","parentKey","getParentKey","parent","get","getChildKeys","includes","process","env","NODE_ENV","children","map","k","every","c","prevSiblingKey","getPrevSiblingKey","prevSibling","getNextSiblingKey","nextSiblingKey","nextSibling","text","size","isConnectedTree","eligibleFirstNodes","toArray","filter","length","firstNode","shift","nodesSeen","currentKey","visitedStack","currentNode","childKeys","unshift","_firstNode","find","isValidTree","_this","blocks","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/DraftTreeInvariants.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n\n    var nextSiblingKey = block.getNextSiblingKey();\n\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n\n      nodesSeen++;\n    }\n\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n\n    var blocks = blockMap.toArray();\n\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAEzC,IAAIC,mBAAmB,GAAG;EACxB;AACF;AACA;EACEC,YAAY,EAAE,SAASA,YAAYA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IACnD,IAAIC,GAAG,GAAGF,KAAK,CAACG,MAAM,EAAE,CAAC,CAAC;;IAE1B,IAAIC,SAAS,GAAGJ,KAAK,CAACK,YAAY,EAAE;IAEpC,IAAID,SAAS,IAAI,IAAI,EAAE;MACrB,IAAIE,MAAM,GAAGL,QAAQ,CAACM,GAAG,CAACH,SAAS,CAAC;MAEpC,IAAI,CAACE,MAAM,CAACE,YAAY,EAAE,CAACC,QAAQ,CAACP,GAAG,CAAC,EAAE;QACxCQ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,+CAA+C,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;QACpH,OAAO,KAAK;MACd;IACF,CAAC,CAAC;;IAGF,IAAIW,QAAQ,GAAGb,KAAK,CAACQ,YAAY,EAAE,CAACM,GAAG,CAAC,UAAUC,CAAC,EAAE;MACnD,OAAOd,QAAQ,CAACM,GAAG,CAACQ,CAAC,CAAC;IACxB,CAAC,CAAC;IAEF,IAAI,CAACF,QAAQ,CAACG,KAAK,CAAC,UAAUC,CAAC,EAAE;MAC/B,OAAOA,CAAC,CAACZ,YAAY,EAAE,KAAKH,GAAG;IACjC,CAAC,CAAC,EAAE;MACFQ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,+CAA+C,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;MACpH,OAAO,KAAK;IACd,CAAC,CAAC;;IAGF,IAAIgB,cAAc,GAAGlB,KAAK,CAACmB,iBAAiB,EAAE;IAE9C,IAAID,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAIE,WAAW,GAAGnB,QAAQ,CAACM,GAAG,CAACW,cAAc,CAAC;MAE9C,IAAIE,WAAW,CAACC,iBAAiB,EAAE,KAAKnB,GAAG,EAAE;QAC3CQ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,yDAAyD,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;QAC9H,OAAO,KAAK;MACd;IACF,CAAC,CAAC;;IAGF,IAAIoB,cAAc,GAAGtB,KAAK,CAACqB,iBAAiB,EAAE;IAE9C,IAAIC,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAIC,WAAW,GAAGtB,QAAQ,CAACM,GAAG,CAACe,cAAc,CAAC;MAE9C,IAAIC,WAAW,CAACJ,iBAAiB,EAAE,KAAKjB,GAAG,EAAE;QAC3CQ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,yDAAyD,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;QAC9H,OAAO,KAAK;MACd;IACF,CAAC,CAAC;;IAGF,IAAIoB,cAAc,KAAK,IAAI,IAAIJ,cAAc,KAAK,IAAI,EAAE;MACtD,IAAIA,cAAc,KAAKI,cAAc,EAAE;QACrCZ,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,iCAAiC,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;QACtG,OAAO,KAAK;MACd;IACF,CAAC,CAAC;;IAGF,IAAIF,KAAK,CAACwB,IAAI,IAAI,EAAE,EAAE;MACpB,IAAIxB,KAAK,CAACQ,YAAY,EAAE,CAACiB,IAAI,GAAG,CAAC,EAAE;QACjCf,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,2BAA2B,EAAEM,GAAG,CAAC,GAAG,KAAK,CAAC;QAChG,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEwB,eAAe,EAAE,SAASA,eAAeA,CAACzB,QAAQ,EAAE;IAClD;IACA,IAAI0B,kBAAkB,GAAG1B,QAAQ,CAAC2B,OAAO,EAAE,CAACC,MAAM,CAAC,UAAU7B,KAAK,EAAE;MAClE,OAAOA,KAAK,CAACK,YAAY,EAAE,IAAI,IAAI,IAAIL,KAAK,CAACmB,iBAAiB,EAAE,IAAI,IAAI;IAC1E,CAAC,CAAC;IAEF,IAAIQ,kBAAkB,CAACG,MAAM,KAAK,CAAC,EAAE;MACnCpB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,yDAAyD,CAAC,GAAG,KAAK,CAAC;MACzH,OAAO,KAAK;IACd;IAEA,IAAImC,SAAS,GAAGJ,kBAAkB,CAACK,KAAK,EAAE;IAC1C,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIC,UAAU,GAAGH,SAAS,CAAC5B,MAAM,EAAE;IACnC,IAAIgC,YAAY,GAAG,EAAE;IAErB,OAAOD,UAAU,IAAI,IAAI,EAAE;MACzB,IAAIE,WAAW,GAAGnC,QAAQ,CAACM,GAAG,CAAC2B,UAAU,CAAC;MAC1C,IAAIG,SAAS,GAAGD,WAAW,CAAC5B,YAAY,EAAE;MAC1C,IAAIc,cAAc,GAAGc,WAAW,CAACf,iBAAiB,EAAE,CAAC,CAAC;;MAEtD,IAAIgB,SAAS,CAACZ,IAAI,GAAG,CAAC,EAAE;QACtB,IAAIH,cAAc,IAAI,IAAI,EAAE;UAC1Ba,YAAY,CAACG,OAAO,CAAChB,cAAc,CAAC;QACtC;QAEA,IAAIT,QAAQ,GAAGwB,SAAS,CAACvB,GAAG,CAAC,UAAUC,CAAC,EAAE;UACxC,OAAOd,QAAQ,CAACM,GAAG,CAACQ,CAAC,CAAC;QACxB,CAAC,CAAC;QAEF,IAAIwB,UAAU,GAAG1B,QAAQ,CAAC2B,IAAI,CAAC,UAAUxC,KAAK,EAAE;UAC9C,OAAOA,KAAK,CAACmB,iBAAiB,EAAE,IAAI,IAAI;QAC1C,CAAC,CAAC;QAEF,IAAIoB,UAAU,IAAI,IAAI,EAAE;UACtB7B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,uBAAuB,EAAEsC,UAAU,CAAC,GAAG,KAAK,CAAC;UACnG,OAAO,KAAK;QACd;QAEAA,UAAU,GAAGK,UAAU,CAACpC,MAAM,EAAE,CAAC,CAAC;MACpC,CAAC,MAAM;QACL,IAAIiC,WAAW,CAACf,iBAAiB,EAAE,IAAI,IAAI,EAAE;UAC3Ca,UAAU,GAAGE,WAAW,CAACf,iBAAiB,EAAE;QAC9C,CAAC,MAAM;UACLa,UAAU,GAAGC,YAAY,CAACH,KAAK,EAAE;QACnC;MACF;MAEAC,SAAS,EAAE;IACb;IAEA,IAAIA,SAAS,KAAKhC,QAAQ,CAACwB,IAAI,EAAE;MAC/Bf,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGhB,OAAO,CAAC,IAAI,EAAE,yDAAyD,EAAEqC,SAAS,EAAEhC,QAAQ,CAACwB,IAAI,CAAC,GAAG,KAAK,CAAC;MACnJ,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb,CAAC;EAED;AACF;AACA;EACEgB,WAAW,EAAE,SAASA,WAAWA,CAACxC,QAAQ,EAAE;IAC1C,IAAIyC,KAAK,GAAG,IAAI;IAEhB,IAAIC,MAAM,GAAG1C,QAAQ,CAAC2B,OAAO,EAAE;IAE/B,IAAI,CAACe,MAAM,CAAC3B,KAAK,CAAC,UAAUhB,KAAK,EAAE;MACjC,OAAO0C,KAAK,CAAC3C,YAAY,CAACC,KAAK,EAAEC,QAAQ,CAAC;IAC5C,CAAC,CAAC,EAAE;MACF,OAAO,KAAK;IACd;IAEA,OAAO,IAAI,CAACyB,eAAe,CAACzB,QAAQ,CAAC;EACvC;AACF,CAAC;AACD2C,MAAM,CAACC,OAAO,GAAG/C,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}