{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\nvar Immutable = require(\"immutable\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar OrderedMap = Immutable.OrderedMap,\n  List = Immutable.List;\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n  var block = blockMap.get(key);\n  if (!block) {\n    return;\n  }\n  blockMap.set(key, func(block));\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList[\"delete\"](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap[\"delete\"](blockKey);\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks[\"delete\"](block.getKey());\n      });\n    });\n  }\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\nmodule.exports = moveBlockInContentState;","map":{"version":3,"names":["ContentBlockNode","require","getNextDelimiterBlockKey","Immutable","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","process","env","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/moveBlockInContentState.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList[\"delete\"](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap[\"delete\"](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks[\"delete\"](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}