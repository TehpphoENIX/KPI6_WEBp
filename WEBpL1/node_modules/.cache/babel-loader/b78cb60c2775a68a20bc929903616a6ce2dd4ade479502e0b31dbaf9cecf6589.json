{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\nvar getSelectionOffsetKeyForNode = require(\"./getSelectionOffsetKeyForNode\");\nvar getUpdatedSelectionState = require(\"./getUpdatedSelectionState\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar isElement = require(\"./isElement\");\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE; // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true; // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset); // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n/**\n * Identify the first leaf descendant for the given node.\n */\n\nfunction getFirstLeaf(node) {\n  while (node.firstChild && (\n  // data-blocks has no offset\n  isElement(node.firstChild) && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n  return node;\n}\n/**\n * Identify the last leaf descendant for the given node.\n */\n\nfunction getLastLeaf(node) {\n  while (node.lastChild && (\n  // data-blocks has no offset\n  isElement(node.lastChild) && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n  return node;\n}\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0; // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !isElement(node) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents node.') : invariant(false) : void 0;\n    var castedNode = node; // assignment only added for flow :/\n    // otherwise it throws in line 200 saying that node can be null or undefined\n\n    node = castedNode;\n    !(node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  } // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\n\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\nmodule.exports = getDraftEditorSelectionWithNodes;","map":{"version":3,"names":["findAncestorOffsetKey","require","getSelectionOffsetKeyForNode","getUpdatedSelectionState","invariant","isElement","nullthrows","getDraftEditorSelectionWithNodes","editorState","root","anchorNode","anchorOffset","focusNode","focusOffset","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","selectionState","needsRecovery","anchorPoint","focusPoint","key","offset","getPointForNonTextNode","firstChild","nodeName","getFirstLeaf","node","getAttribute","getLastLeaf","lastChild","editorRoot","startNode","childOffset","offsetKey","process","env","NODE_ENV","castedNode","childNodes","length","firstLeaf","nodeBeforeCursor","leafKey","textLength","getTextContentLength","lastLeaf","textContent","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\n\nvar getSelectionOffsetKeyForNode = require(\"./getSelectionOffsetKeyForNode\");\n\nvar getUpdatedSelectionState = require(\"./getUpdatedSelectionState\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar isElement = require(\"./isElement\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE; // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true; // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset); // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n/**\n * Identify the first leaf descendant for the given node.\n */\n\n\nfunction getFirstLeaf(node) {\n  while (node.firstChild && ( // data-blocks has no offset\n  isElement(node.firstChild) && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n\n  return node;\n}\n/**\n * Identify the last leaf descendant for the given node.\n */\n\n\nfunction getLastLeaf(node) {\n  while (node.lastChild && ( // data-blocks has no offset\n  isElement(node.lastChild) && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0; // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !isElement(node) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents node.') : invariant(false) : void 0;\n    var castedNode = node; // assignment only added for flow :/\n    // otherwise it throws in line 200 saying that node can be null or undefined\n\n    node = castedNode;\n    !(node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  } // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n\n\n  if (childOffset === 0) {\n    var key = null;\n\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\n\n\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}