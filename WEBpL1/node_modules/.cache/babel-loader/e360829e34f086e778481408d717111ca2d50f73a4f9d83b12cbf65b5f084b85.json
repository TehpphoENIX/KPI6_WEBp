{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n'use strict';\n\nvar invariant = require(\"./invariant\"); // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\n\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\n\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\n\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n  if (index + 1 === str.length) {\n    return false;\n  }\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\n\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\n\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\n\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n  var len = 0;\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n  return len;\n}\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\n\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0; // Call the native functions if there's no surrogate char\n\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  } // Obvious cases\n\n  var size = str.length;\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  } // Find the actual starting position\n\n  var posA = 0;\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n    if (posA < 0) {\n      posA = 0;\n    }\n  } // Find the actual ending position\n\n  var posB = size;\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n  return str.substring(posA, posB);\n}\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\n\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\n\nfunction getCodePoints(str) {\n  var codePoints = [];\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n  return codePoints;\n}\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\nmodule.exports = UnicodeUtils;","map":{"version":3,"names":["invariant","require","SURROGATE_HIGH_START","SURROGATE_HIGH_END","SURROGATE_LOW_START","SURROGATE_LOW_END","SURROGATE_UNITS_REGEX","isCodeUnitInSurrogateRange","codeUnit","isSurrogatePair","str","index","length","process","env","NODE_ENV","first","charCodeAt","second","hasSurrogateUnit","test","getUTF16Length","pos","strlen","len","substr","start","undefined","Infinity","size","posA","posB","substring","end","Math","abs","getCodePoints","codePoints","push","codePointAt","UnicodeUtils","module","exports"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/fbjs/lib/UnicodeUtils.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n'use strict';\n\nvar invariant = require(\"./invariant\"); // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\n\n\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\n\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\n\n\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n\n  if (index + 1 === str.length) {\n    return false;\n  }\n\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\n\n\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\n\n\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\n\n\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n\n  var len = 0;\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n\n  return len;\n}\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\n\n\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0; // Call the native functions if there's no surrogate char\n\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  } // Obvious cases\n\n\n  var size = str.length;\n\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  } // Find the actual starting position\n\n\n  var posA = 0;\n\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n\n    if (posA < 0) {\n      posA = 0;\n    }\n  } // Find the actual ending position\n\n\n  var posB = size;\n\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n\n  return str.substring(posA, posB);\n}\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\n\n\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n\n  if (start < 0) {\n    start = 0;\n  }\n\n  if (end < 0) {\n    end = 0;\n  }\n\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\n\n\nfunction getCodePoints(str) {\n  var codePoints = [];\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n\n  return codePoints;\n}\n\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\nmodule.exports = UnicodeUtils;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}