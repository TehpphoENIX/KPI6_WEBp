{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.draftjsToHtml = factory());\n})(this, function () {\n  'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n          counter += trigger.length;\n        }\n      }\n    }\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n        length = range.length,\n        key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n      inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n          case '&':\n            return '&amp;';\n          case '<':\n            return '&lt;';\n          case '>':\n            return '&gt;';\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n      if (html) {\n        return html;\n      }\n    }\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n      return replacedText;\n    }\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n      return replacedText;\n    }\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n      text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n        entityMap = editorContent.entityMap;\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n    return html.join('');\n  }\n  return draftToHtml;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","draftjsToHtml","forEach","obj","callback","key","hasOwnProperty","call","isEmptyString","str","undefined","length","trim","blockTypesMapping","unstyled","blockquote","code","getBlockTag","type","getBlockStyle","data","styles","value","concat","getHashtagRanges","blockText","hashtagConfig","sections","counter","startIndex","text","trigger","separator","substr","indexOf","endIndex","hashtag","push","offset","getSections","block","lastOffset","sectionRanges","entityRanges","map","range","sort","s1","s2","r","start","end","entityKey","isAtomicEntityBlock","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","i","style","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","ch","join","addStylePropertyMarkup","styleString","test","getEntityMarkup","entityMap","customEntityTransform","entity","html","url","targetOption","alignment","src","alt","height","width","getInlineStyleSections","styleSections","from","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","styleSection","getInlineStyleSectionMarkup","styleTagSections","styleSectionText","stylePropertySection","getSectionMarkup","entityInlineMarkup","inlineStyleSections","getBlockInnerMarkup","blockMarkup","getBlockMarkup","directional","blockHtml","blockTag","blockStyle","isList","blockType","getListMarkup","listBlocks","listHtml","nestedListBlock","previousBlock","nestedBlock","depth","draftToHtml","editorContent","blocks"],"sources":["C:/Users/Teh_phoENIX/source/repos/WEBp/WEBpL1/node_modules/draftjs-to-html/lib/draftjs-to-html.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.draftjsToHtml = factory());\n}(this, (function () { 'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}